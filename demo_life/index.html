<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Story of Your Life</title>
  <style>
    canvas {
      position: absolute;
    }
  </style>
</head>
<body>
<script>
'use strict'

const life = Math.floor(75 * 365.25)
const age = Math.floor(30 * 365.25)
const today = new Date().getDay()

// === constant layout metrics. The rest is dynamic
const leftBlockRadius = [99, 0, 0, 99], rightBlockRadius = [0, 99, 99, 0]
const gridGap = 8

// === state
let customDot = null
let inputs = {
  pointer: {x: -Infinity, y: -Infinity}, // btw, on page load, there's no way to render a first cursor state =(
  clicked: false,
}
let canvas = document.createElement('canvas')
let ctx = canvas.getContext('2d')
document.body.appendChild(canvas)

// === events
window.addEventListener('resize', () => render())
window.addEventListener('mousemove', (e) => {
  // when scrolling (which might schedule a render), a container's mousemove doesn't trigger, so the pointer's local coordinates are stale
  // this means we should only use pointer's global coordinates, which is always right (thus the subtraction of scroll)
  inputs.pointer.x = e.pageX -/*toGlobal*/window.scrollX; inputs.pointer.y = e.pageY -/*toGlobal*/window.scrollY
  // btw, pointer can exceed document bounds, e.g. dragging reports back out-of-bound, legal negative values
  render()
})
window.addEventListener('click', (e) => {
  inputs.clicked = true
  // needed to update coords even when we already track mousemove. E.g. in Chrome, right click context menu, move elsewhere, then click to dismiss. BAM, mousemove triggers with stale/wrong (??) coordinates... Click again without moving, and now you're clicking on the wrong thing
  inputs.pointer.x = e.pageX - window.scrollX; inputs.pointer.y = e.pageY - window.scrollY
  render()
})

// === hit testing logic. Boxes' hit area should be static and not follow their current animated state usually (but we can do either). Use the dynamic area here for once
function hitTest(blockSize, countX, countY, gridLeft, gridTop, gridFinalSizeX, gridFinalSizeY, pointer) {
  const px = pointer.x-/*toLocal*/gridLeft
  const py = pointer.y-/*toLocal*/gridTop
  if (px < 0 || px > gridFinalSizeX || py < 0 || py > gridFinalSizeY) return null
  return Math.floor(py / blockSize) * countX + Math.floor(px / blockSize)
}

function render() {
  // === step 1: batched DOM reads (to avoid accidental DOM read & write interleaving)
  const devicePixelRatio = window.devicePixelRatio
  const windowSizeX = document.documentElement.clientWidth
  const windowSizeY = window.innerHeight
  const gridSizeX = windowSizeX - gridGap
  const gridSizeY = windowSizeY - gridGap
  let {pointer} = inputs

  const blockSize_ = (life * Math.sqrt((4*life*gridSizeX*gridSizeY + (7*gridSizeY)**2) / (life**2)) + 7 * gridSizeY) / 2 / life
  const countX = Math.floor((gridSizeX / blockSize_) / 7) * 7
  const countY = Math.ceil(life / countX)
  const blockSize = gridSizeY / countY
  const gridFinalSizeX = countX * blockSize
  const gridFinalSizeY = countY * blockSize
  const gridLeft = (windowSizeX - gridFinalSizeX) / 2 // center
  const gridTop = (windowSizeY - gridFinalSizeY) / 2 // center

  // === step 2: handle inputs-related state change
  const hover = hitTest(blockSize, countX, countY, gridLeft, gridTop, gridFinalSizeX, gridFinalSizeY, pointer)
  const newCustomDot =
    inputs.clicked && hover === customDot ? null
    : inputs.clicked ? hover
    : customDot

  // === step 5: render. Batch DOM writes
  // no blurry canvas: coderwall.com/p/vmkk6a/how-to-make-the-canvas-not-look-like-crap-on-retina
  canvas.width = gridFinalSizeX * devicePixelRatio // different than canvas.style.width. Btw this clears the canvas as well
  canvas.height = gridFinalSizeY * devicePixelRatio
  canvas.style.width = gridFinalSizeX
  canvas.style.height = gridFinalSizeY
  canvas.style.left = gridLeft
  canvas.style.top = gridTop
  ctx.scale(devicePixelRatio, devicePixelRatio)
  ctx.clearRect(0, 0, gridFinalSizeX, gridFinalSizeY)

  ctx.strokeStyle = 'hsl(120, 73%, 30%)'
  ctx.lineWidth = 0.5
  for (let i = 0; i < life; i++) {
    const todayOffset = i + 10 - today
    ctx.fillStyle =
      i === hover || i === newCustomDot ? 'orange'
      : todayOffset < age ? 'hsl(120, 73%, 75%)'
      : todayOffset === age ? 'hsl(120, 73%, 40%)'
      : i === life - 1 ? 'red'
      : 'white'

    const x = i % countX * blockSize
    const y = Math.floor(i / countX) * blockSize

    const radius =
      i % 7 === 0 ? leftBlockRadius
      : i % 7 === 6 ? rightBlockRadius
      : 0
    ctx.beginPath()
    ctx.roundRect(x, y, blockSize, blockSize, radius)
    ctx.fill()
    ctx.stroke()
  }

  // === step 6: update state & prepare for next frame
  inputs.clicked = false
  customDot = newCustomDot
}

render()
</script>
</body>
